import { jsPDF } from 'jspdf';
import { createTool } from '@convex-dev/agent';
import { jsonSchema } from 'ai';
import { ActionCtx } from '../../_generated/server';
import { internal } from '../../_generated/api';

/**
 * PDF Generator Tool
 * 
 * Generates professional PDF documents from text content and saves them to storage.
 * Perfect for compiling research, reports, summaries, etc.
 */

export function createGeneratePDFTool(ctx: ActionCtx) {
  return createTool({
    description: `Generate a professional PDF document from text content and save it for download.
Use this when the user asks you to:
- Create a report or summary
- Compile research findings into a document
- Generate a PDF with specific content
- Save information to a PDF file
- Create a downloadable report

The tool creates a formatted PDF with title, author, date, and proper styling, saves it to storage, and returns a download URL.`,
    args: jsonSchema<{
      title: string;
      content: string;
      author?: string;
      subtitle?: string;
      filename?: string;
    }>({
      type: 'object',
      properties: {
        title: { 
          type: 'string', 
          description: 'Title of the PDF document' 
        },
        content: { 
          type: 'string', 
          description: 'The main content in markdown format' 
        },
        author: { 
          type: 'string', 
          description: 'Author name (optional)' 
        },
        subtitle: { 
          type: 'string', 
          description: 'Subtitle (optional)' 
        },
        filename: { 
          type: 'string', 
          description: 'Filename without extension (optional, defaults to title)' 
        },
      },
      required: ['title', 'content'],
    }),
    handler: async (_toolCtx, args: any) => {
      const { title, content, author, subtitle, filename } = args as {
        title: string;
        content: string;
        author?: string;
        subtitle?: string;
        filename?: string;
      };
      
      try {
        const doc = new jsPDF();
        const safeFilename = (filename || title).replace(/[^a-zA-Z0-9-_]/g, '_');
        
        // Add title
        doc.setFontSize(24);
        doc.setTextColor(0, 0, 0);
        doc.text(title, 20, 30);
        
        // Add subtitle if provided
        let yPosition = 45;
        if (subtitle) {
          doc.setFontSize(14);
          doc.setTextColor(100, 100, 100);
          doc.text(subtitle, 20, yPosition);
          yPosition += 15;
        }
        
        // Add author if provided
        if (author) {
          doc.setFontSize(11);
          doc.setTextColor(128, 128, 128);
          doc.text(`By: ${author}`, 20, yPosition);
          yPosition += 20;
        }
        
        // Add date
        doc.setFontSize(10);
        doc.text(`Generated: ${new Date().toLocaleDateString()}`, 20, yPosition);
        yPosition += 20;
        
        // Add separator line
        doc.setDrawColor(200, 200, 200);
        doc.line(20, yPosition, 190, yPosition);
        yPosition += 15;
        
        // Process content - convert markdown to plain text
        let processedContent = content
          .replace(/#{1,6}\s/g, '') // Remove markdown headers
          .replace(/\*\*/g, '') // Remove bold markers
          .replace(/\*/g, '') // Remove italic markers
          .replace(/`{3}[\s\S]*?`{3}/g, '[Code Block]') // Replace code blocks
          .replace(/`([^`]+)`/g, '$1') // Remove inline code markers
          .replace(/\[([^\]]+)\]\([^\)]+\)/g, '$1') // Replace links with text
          .replace(/\n{3,}/g, '\n\n'); // Normalize newlines
        
        // Add content
        doc.setFontSize(11);
        doc.setTextColor(0, 0, 0);
        
        const lines = doc.splitTextToSize(processedContent, 170);
        
        // Add lines with pagination
        for (let i = 0; i < lines.length; i++) {
          if (yPosition > 270) {
            doc.addPage();
            yPosition = 20;
          }
          doc.text(lines[i], 20, yPosition);
          yPosition += 6;
        }
        
        // Add footer on each page
        const pageCount = doc.getNumberOfPages();
        for (let i = 1; i <= pageCount; i++) {
          doc.setPage(i);
          doc.setFontSize(8);
          doc.setTextColor(150, 150, 150);
          doc.text(`${title} - Page ${i} of ${pageCount}`, 20, 285);
          doc.text('Generated by ClawSync AI', 160, 285);
        }
        
        // Convert to buffer
        const pdfBuffer = doc.output('arraybuffer');
        const pdfBlob = new Uint8Array(pdfBuffer);
        
        // Save to Convex storage directly
        const fullFilename = `${safeFilename}.pdf`;
        
        // Generate upload URL
        const uploadUrl = await ctx.storage.generateUploadUrl();
        
        // Upload the file data directly
        const response = await fetch(uploadUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/pdf',
          },
          body: pdfBlob,
        });
        
        if (!response.ok) {
          throw new Error(`Failed to upload PDF: ${response.status}`);
        }
        
        // Get storage ID from response
        const responseText = await response.text();
        let storageId: string;
        
        try {
          const jsonResponse = JSON.parse(responseText);
          storageId = jsonResponse.storageId || jsonResponse.id;
        } catch {
          // Extract from URL if needed
          const urlParts = uploadUrl.split('/');
          storageId = urlParts[urlParts.length - 1];
        }
        
        // Save metadata via mutation
        await ctx.runMutation(internal.fileStorage.saveMetadata, {
          storageId: storageId as any,
          filename: fullFilename,
          contentType: 'application/pdf',
        });
        
        // Get download URL
        const downloadUrl = await ctx.storage.getUrl(storageId as any);
        
        if (!downloadUrl) {
          throw new Error('Failed to get download URL');
        }
        
        return {
          success: true,
          filename: fullFilename,
          pageCount: pageCount,
          downloadUrl: downloadUrl,
          storageId: storageId,
          message: `PDF "${title}" generated successfully with ${pageCount} page(s). Download it here: ${downloadUrl}`,
          contentLength: processedContent.length,
        };
      } catch (error) {
        console.error('PDF Generation Error:', error);
        return {
          success: false,
          error: error instanceof Error ? error.message : 'Failed to generate PDF',
          message: 'Could not generate PDF document. Please try again with different content.',
        };
      }
    },
  });
}
